#!/bin/bash
#+
# This script invokes Blender to render the specified .blend file. It
# allows the specification of various rendering settings directly from
# the command line, overriding settings from the .blend file. It also
# has the option for stereoscopic rendering, by doing the render
# twice, offsetting the camera along its local X axis, and combining
# the resulting images to produce a stereo pair. Besides Blender, it
# also needs the Qahirah wrapper (<https://gitlab.com/ldo/qahirah> or
# <https://github.com/ldo/qahirah>) for the Cairo graphics library.
# Invoke it as follows:
#
#     render-batch [options...] blendfile [dest]
#
# where blendfile is the .blend file to render, and dest is the name
# to give the output PNG file if rendering a single frame, or the name
# of the directory into which to save the numbered frames for an
# animation. dest must be specified when rendering an animation; if
# omitted for a single frame, it defaults to the basename of the input
# blend file with “.png” appended, saved in the current directory.
#
# Valid options are
#
#    --animation
#          specifies that an animation sequence is to be rendered.
#          If omitted, a single frame is rendered.
#    --arrange=[across]|down[:n]
#          specifies how the images are to be arranged, if multiple
#          cameras are specified: across (the default) or down. The
#          optional n specifies how many images are to fit in one
#          row (if across) or column (if down).
#    --blender=blender
#          specifies the path to the Blender executable. Defaults to
#          searching for the name “blender” in your PATH.
#    --camera=camera
#          specifies the name of the camera to use. May be specified
#          more than once, to render images from multiple cameras
#          across or down (depending on --arrange).
#    --crash-protect
#          spawns a separate child process to do the rendering,
#          with automatic resume after a crash. Currently only
#          supported together with --animation and
#          --existing=(replace-all|skip).
#          (Best considered experimental for now.)
#    --digits=digits
#          for an animation, the number of digits for for formatting
#          frame numbers to use in names of output frame files. If
#          omitted, defaults to 4. The generated names will include
#          leading zeroes as necessary to make up this number of digits,
#          eg “0001.png”, “0002.png” etc.
#    --preexec=script
#          executes the specified Python code prior to the rendering.
#          May be specified multiple times; the values are concatenated
#          in sequence, separated by newlines.
#    --existing=error|overwrite|replace-all|skip
#          specifies what to do if an output image file already exists:
#            error       -- signal an error and abort the render
#            overwrite   -- overwrite the output file
#            replace-all -- only for animations: replaces any existing
#                           output directory (and its contents) with the
#                           new frames, but only on successful completion
#                           of the entire render.
#            skip        -- skip rendering this frame. If rendering an
#                           animation, the rendering continues with any
#                           remaining frames.
#          If omitted, the default is error.
#    --frame=framenr
#    --frames=[[start],[end][,step]]
#          specifies the frame number (if a single frame) or frame
#          range (if an animation) to be rendered.
#    --layers=layers
#          specifies the enabling/disabling of specified scene layers.
#          “layers” consists of a comma-separated list of one or more
#          layer numbers in the range [1 .. 20], optionally preceded
#          by “+” or “-”. “+” indicates to enable the specified layers
#          (in addition to those already enabled); “-” indicates to
#          disable the specified layers, and the absence of either
#          means the specified layers should be enabled and all others
#          disabled.
#    --renumber=renumber
#          for an animation, the starting number to use to generate
#          names for the output frame files. If omitted, defaults to
#          the frame start number.
#    --stereo=offset
#          specifies that a stereoscopic image is to be rendered.
#          offset is the distance in BU to offset the camera to each
#          side from its initial position to generate the image for
#          each eye. If omitted, a single image is rendered.
#    --out=dest
#          alternative way to specify the render destination.
#    --percent=percent
#          specifies the percentage of the render size at which to
#          generate the images. If omitted, the default is 100 if
#          --resolution is specified, otherwise the default is
#          the setting in the .blend file.
#    --resolution=[width]:[height]
#          specifies the dimensions in pixels of each rendered image.
#          At least one of width and height must be specified; if one
#          is omitted, it is calculated from the other so as to maintain
#          the existing aspect ratio.
#    --rotate=angle
#          rotates the images by the specified angle in
#          degrees (which must be a whole multiple of 90).
#    --samples=samples
#          the number of samples per pixel (Cycles renderer, or
#          BI renderer in Raytrace gather mode, only).
#    --scene=scene
#          specifies the scene to render.
#    --threads=n
#          how many concurrent threads to use for rendering
#          (defaults to “auto”).
#    --time-remap=old:new
#          alters the rendered frame rate to be
#          (new ÷ old) × the existing frame rate.
#          If you don’t specify explicit start and end frame numbers,
#          then the corresponding values set in the .blend file are
#          automatically remapped to get as close as possible to the
#          same start and end times, rounded to the nearest whole frame
#          numbers. But note that the frame step remains unchanged.
#    --trusted
#          treat the .blend file as being loaded from a trusted
#          source. This will enable autoexecution of scripts
#          (e.g. drivers) which might have been disabled otherwise.
#    --use-camera-layers
#          sets the visible layers to exactly those on which the
#          active camera is visible.
#    --vse
#          indicates that the render is the output of the Video
#          Sequence Editor. That means the presence of a camera
#          in the scene is ignored. Incompatible with the --camera
#          and --stereo options.
#
# Unless otherwise specified, omitted options default to the
# values saved in the blend file.
#
# For stereoscopic rendering, the output file will contain the
# two eye images side-by-side, the image for the right eye on
# the left and vice versa, for viewing as “cross-eyed” stereo.
#
# Copyright 2013-2018 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY-SA <http://creativecommons.org/licenses/by-sa/4.0/>.
#-

opterror()
  {
    echo "$0: $1" 1>&2
    exit 3
  } # opterror

blender=blender
nr_cameras=0
arrange=
scene=
samples=
vse=
stereo_offset=
layers=
use_camera_layers=
digits=4
reunumber=
render_percentage=
render_width=
render_height=
rotate=
out=
existing=error
animation=
crash_protect=
threads=
time_remap=
crossed=
trusted=
preexec=
for ((;;)); do
    if [ "${1:0:2}" != "--" ]; then
        break
    fi
    if [ "$1" == "--" ]; then
        shift
        break
    fi
    opt="${1:2:${#1}}"
    shift
    val="${opt#*=}"
    opt="${opt%%=*}"
    if [ "$opt" = "animation" ]; then
        animation=1
    elif [ "$opt" = "arrange" ]; then
        val1="${val%%:*}"
        if [ "$val1" != "$val" ]; then
            val2="${val#*:}"
        else
            val2=""
        fi
        if [ "$val1" != "across" -a "$val1" != "down" ]; then
            opterror "--arrange type must be “across” or “down”"
        fi
        if [[ "$val2" = *[^0-9]* ]]; then
            opterror "--arrange value must be integer"
        fi
        arrange="$val"
    elif [ "$opt" = "blender" ]; then
        blender="$val"
    elif [ "$opt" = "camera" ]; then
        nr_cameras=$((nr_cameras + 1))
        export RENDER_camera_${nr_cameras}="$val"
    elif [ "$opt" = "crash-protect" ]; then
        crash_protect=1
    elif [ "$opt" = "crossed" ]; then
        crossed=1
    elif [ "$opt" = "digits" ]; then
        digits="$val"
    elif [ "$opt" = "existing" ]; then
        if [ "$val" != "error" -a "$val" != "overwrite" -a "$val" != "replace-all" -a "$val" != "skip" ]; then
            opterror "--existing value must be “error”, “overwrite”, “replace-all” or “skip”"
        fi
        existing="$val"
    elif [ "$opt" = "frame" -o "$opt" = "frames" ]; then
        frame_spec="$val"
    elif [ "$opt" = "layers" ]; then
        layers="$val"
    elif [ "$opt" = "out" ]; then
        out="$val"
    elif [ "$opt" = "percent" ]; then
        render_percentage="$val"
    elif [ "$opt" = "preexec" ]; then
        if [ -n "$preexec" ]; then
            preexec="$preexec"$'\n'"$val"
        else
            preexec="$val"
        fi
    elif [ "$opt" = "renumber" ]; then
        renumber="$val"
    elif [ "$opt" = "resolution" ]; then
        IFS=':' read -a items <<<"$val"
        render_width="${items[0]}"
        render_height="${items[1]}"
        if [ -z "$render_percentage" ]; then
            render_percentage=100
        fi
    elif [ "$opt" = "rotate" ]; then
        if [ $(($val % 90)) != 0 ]; then
            opterror "--rotate value must be multiple of 90"
        fi
        rotate=$(($val / 90))
    elif [ "$opt" = "samples" ]; then
        samples="$val"
    elif [ "$opt" = "scene" ]; then
        scene="$val"
    elif [ "$opt" = "stereo" ]; then
        stereo_offset="$val"
    elif [ "$opt" = "threads" ]; then
        threads="$val"
    elif [ "$opt" = "time-remap" ]; then
        time_remap="$val"
    elif [ "$opt" = "trusted" ]; then
        trusted=1
    elif [ "$opt" = "use-camera-layers" ]; then
        use_camera_layers=1
    elif [ "$opt" = "vse" ]; then
        vse=1
    else
        opterror "bad option $opt"
    fi
done
if [ -z "$(type -p "$blender")" ]; then
    opterror "no such executable “$blender”"
fi
if [ -z "$out" -a $# = 2 ]; then
    out="$2"
    set -- "$1"
fi
if [ $# != 1 ]; then
    opterror $'Usage:\n\t'"$0 "$'<blendfile>'
fi
blendfile="$1"
export RENDER_blendfile="$blendfile"

if [ -n "$stereo_offset" -a $nr_cameras -gt 1 ]; then
    opterror "cannot specify --stereo with more than one --camera"
fi
if [ $nr_cameras -ne 0 ]; then
    if [ -n "$vse" ]; then
        opterror "cannot specify --vse with --camera"
    fi
    unset RENDER_camera_$((nr_cameras + 1)) # just in case
fi
if [ -n "$stereo_offset" -a -n "$vse" ]; then
    opterror "cannot specify --vse with --stereo"
fi
if [ -n "$use_camera_layers" -a -n "$layers" ]; then
    opterror "cannot specify --use-camera-layers with --layers"
fi
if [ -n "$crash_protect" ]; then
    if [ -z "$animation" -o \( "$existing" != "replace-all" -a "$existing" != "skip" \) ]; then
        opterror "--crash-protect currently only allowed with --animation and --existing=replace-all|skip"
    fi
fi

# pass parameters to Python script in environment variables to avoid
# problems with special characters
export RENDER_stereo_offset="$stereo_offset"
if [ $animation ]; then
    if [ -z "$out" -o \( \( "$existing" != "replace-all" -o -e "$out" \) -a ! -d "$out" \) ]; then
        opterror "must specify --out directory for animation frames"
    fi
    IFS=',' read -a frame_spec <<<"$frame_spec"
    export RENDER_frame_start="${frame_spec[0]}"
    export RENDER_frame_end="${frame_spec[1]}"
    export RENDER_frame_step="${frame_spec[2]}"
else
    export RENDER_frame_start="$frame_spec"
fi
export RENDER_animation="$animation"
export RENDER_crash_protect="$crash_protect"
export RENDER_time_remap="$time_remap"
export RENDER_vse="$vse"
if [ -n "$out" ]; then
    RENDER_out="$out"
else
    RENDER_out="${blendfile##*/}"
    RENDER_out="${RENDER_out%%.*}.png"
fi
export RENDER_out
export RENDER_arrange="$arrange"
export RENDER_existing="$existing"
export RENDER_scene="$scene"
export RENDER_layers="$layers"
export RENDER_use_camera_layers="$use_camera_layers"
export RENDER_samples="$samples"
export RENDER_threads="$threads"
export RENDER_percentage="$render_percentage"
export RENDER_width="$render_width"
export RENDER_height="$render_height"
export RENDER_rotate="$rotate"
export RENDER_preexec="$preexec"
export RENDER_crossed="$crossed"
export RENDER_trusted="$trusted"
export RENDER_digits="$digits"
export RENDER_renumber="$renumber"

exec "$blender" -noaudio -b -P <(cat <<'EOD'
import sys
import os
import io
import time
import signal
import tempfile
import shutil
import bpy
import mathutils
import qahirah as qah
from qahirah import \
    CAIRO, \
    Colour, \
    Rect, \
    Vector

try :
    os.wait() # gobble zombie child of shell which was previously in this process slot
except ChildProcessError :
    # can happen intermittently?
    pass
#end try

#+
# Useful stuff
#-

units = \
    ( # sequence of quadruples, first element is multiplier to apply to
      # previous quadruple, or nr of seconds for first quadruple, second
      # element is abbreviated unit name, third element is singular unit
      # name, fourth element is plural unit name.
        (1, "s", "second", "seconds"),
        (60, "m", "minute", "minutes"),
        (60, "h", "hour", "hours"),
        (24, "d", "day", "days"),
        (7, "wk", "week", "weeks"),
    )

def format_elapsed(interval, long_form = False, seconds_places = 0) :
    "returns an accurate indication of the specified interval in seconds." \
    " long_form indicates whether to display the units in long form or short form," \
    " while seconds_places indicates the number of decimal places to use for showing" \
    " the seconds."
    interval = round(interval)
    unitindex = 0
    result = ""
    while True :
        if unitindex == len(units) :
            break
        unit = units[unitindex]
        if unitindex + 1 < len(units) :
            factor = units[unitindex + 1][0]
            place = interval % factor
        else :
            factor = None
            place = interval
        #end if
        place = "{:.{places}f}{}".format \
          (
            place,
            (unit[1], " " + unit[2:4][place != 1])[long_form],
            places = (0, seconds_places)[unitindex == 0]
          )
        result = \
            (
                place
            +
                ("", (" ", (", ", " and " )[unitindex == 1])[long_form])[unitindex > 0]
            +
                result
            )
        if factor == None :
            break
        interval //= factor
        if interval == 0 :
            break
        unitindex += 1
    #end while
    return \
        result
#end format_elapsed

def frame_name(frame_nr) :
    "computes the frame filename for the specified frame number. Assumes frame_nr_adjust" \
    " and frame_digits have been initialized."
    return \
        "{:0{digits}d}.png".format(frame_nr + frame_nr_adjust, digits = frame_digits)
#end frame_name

def get_optional_env(varname, convert = None) :
    # returns the value of the specified environment variable, converted
    # by applying the convert function if specified; returns None if
    # the value of the variable was not specified or empty.
    val = os.getenv(varname, "")
    if val != "" :
        if convert != None :
            val = convert(val)
        #end if
    else :
        val = None
    #end if
    return \
        val
#end get_optional_env

class DummyTempDir :
    "a replacement for tempfile.TemporaryDirectory for when I\n" \
    "don’t actually need a temp directory."

    def __init__(self, prefix) :
        pass
    #end __init__

    def __enter__(self) :
        return "dummy" # got to return something usable as part of a pathname
    #end __enter__

    def __exit__(self, exception_type, exception_value, traceback) :
        pass
    #end __exit__

#end DummyTempDir

def parse_layers_spec(s) :
    replace_layers = None
    add_layers = None
    remove_layers = None

    ch = None
    def nextch() :
        nonlocal ch
        ch = f.read(1)
    #end nextch

#begin parse_layers_spec
    if len(s) > 0 :
        layers_seen = set()
        f = io.StringIO(s)
        nextch()
        adding = None
        cur_layers = None
        while True :
            curno = None
            while True :
                if ch < "0" or ch > "9" :
                    break
                if curno == None :
                    curno = 0
                #end if
                curno = curno * 10 + ord(ch) - ord("0")
                nextch()
            #end while
            if curno != None :
                if curno < 1 or curno > 20 :
                    raise ValueError("layer number {} out of range [1 .. 20]".format(curno))
                #end if
                if curno in layers_seen :
                    raise ValueError("duplicate layer number {}".format(curno))
                #end if
                layers_seen.add(curno)
                if cur_layers == None :
                    if adding == True :
                        if add_layers == None :
                            add_layers = set()
                        #end if
                        cur_layers = add_layers
                    elif adding == False :
                        if remove_layers == None :
                            remove_layers = set()
                        #end if
                        cur_layers = remove_layers
                    else :
                        if replace_layers == None :
                            replace_layers = set()
                        #end if
                        cur_layers = replace_layers
                    #end if
                #end if
                cur_layers.add(curno)
            #end if
            if ch == "" :
                break
            if ch == "+" :
                if replace_layers != None :
                    raise SyntaxError("cannot both add and replace layers")
                #end if
                adding = True
                cur_layers = None
                nextch()
            elif ch == "-" :
                if replace_layers != None :
                    raise SyntaxError("cannot both remove and replace layers")
                #end if
                adding = False
                cur_layers = None
                nextch()
            elif ch == "," :
                nextch()
            else :
                raise SyntaxError("unexpected character {} in layer spec".format(ord(ch)))
            #end if
        #end while
    #end if
    return \
        replace_layers, add_layers, remove_layers
#end parse_layers_spec

def remap_frame_nr(frame_nr) :
    # returns frame_nr suitably adjusted for any time_remap parameters.
    if time_remap != None :
        result = round((frame_nr - 1) * (time_remap[1] / time_remap[0])) + 1
    else :
        result = frame_nr
    #end if
    return \
        result
#end remap_frame_nr

def get_image_from_png(filename) :
    # loads the contents of a PNG file as an ImageSurface, applying any
    # appropriate rotation.
    image = qah.ImageSurface.create_from_png(filename)
    if rotate != 0 :
        image_format = image.format
        src_dimensions = image.dimensions
        if rotate & 1 != 0 :
            dst_dimensions = Vector(src_dimensions.y, src_dimensions.x)
        else :
            dst_dimensions = src_dimensions
        #end if
        rotate_point = \
            Vector \
              (
                x = (src_dimensions.y, src_dimensions.x, src_dimensions.x)[rotate - 1],
                y = (src_dimensions.y, src_dimensions.y, src_dimensions.x)[rotate - 1],
              )
        src = \
            (qah.Pattern.create_for_surface(image)
                .set_matrix(qah.Matrix.rotate(- rotate / 4 * qah.circle, rotate_point / 2))
            )
        image = qah.ImageSurface.create \
          (
            format = image_format,
            dimensions = dst_dimensions
          )
        (qah.Context.create(image)
            .set_source(src)
            .paint()
        )
        image.flush()
    #end if
    return \
        image
#end get_image_from_png

def set_layers(replace_layers = None, add_layers = None, remove_layers = None) :
    "sets the current set of active layers to those in replace_layers, or" \
    " alternatively adds add_layers to the active layers and then removes remove_layers" \
    " from the active layers. Each value is a set of 0-based integer layer indices."
    # Subtle trickiness here: if this scene is the already-active
    # scene, and only one layer is active, but I am turning it
    # off, Blender will ignore my attempt to do so until some other
    # layer becomes active.
    if replace_layers != None :
        assert add_layers == None and remove_layers == None
        remove_layers = set \
            (i + 1
                for i in range(len(bpy.context.scene.layers))
                if bpy.context.scene.layers[i] and (i + 1 not in replace_layers)
            )
        add_layers = replace_layers - remove_layers
    #end if
    # turn on all layers I am enabling first:
    if add_layers != None :
        for i in add_layers :
            bpy.context.scene.layers[i - 1] = True
        #end for
    #end if
    # then turn off the ones I am disabling:
    if remove_layers != None :
        for i in remove_layers :
            bpy.context.scene.layers[i - 1] = False
        #end for
    #end if
#end set_layers

def set_layers_from_object(obj) :
    "sets the current set of active layers to exactly those on which" \
    " the object obj is visible."
    set_layers(replace_layers = set(i + 1 for i in range(20) if obj.layers[i]))
#end set_layers_from_object

#+
# Mainline
#-

blendfile = os.getenv("RENDER_blendfile")
trusted = os.getenv("RENDER_trusted", "") != ""
bpy.ops.wm.open_mainfile(filepath = blendfile, use_scripts = trusted)
vse_render = os.getenv("RENDER_vse", "") != ""
stereo_offset = get_optional_env("RENDER_stereo_offset", float)
render_percentage = get_optional_env("RENDER_percentage")
if render_percentage != None :
    try :
        render_percentage = int(render_percentage)
    except ValueError :
        # allow fractions, which Blender itself does not
        render_percentage = float(render_percentage)
    #end try
#end if
render_width = get_optional_env("RENDER_width", int)
render_height = get_optional_env("RENDER_height", int)
rotate = get_optional_env("RENDER_rotate", int)
if rotate != None :
    rotate %= 4
else :
    rotate = 0
#end if
animation = os.getenv("RENDER_animation", "") != ""
crash_protect = os.getenv("RENDER_crash_protect", "") != ""
time_remap = get_optional_env("RENDER_time_remap")
if time_remap != None :
    time_remap = tuple(int(i) for i in time_remap.split(":", 1))
#end if
preexec = get_optional_env("RENDER_preexec")
crossed = os.getenv("RENDER_crossed", "") != ""
frame_digits = int(os.getenv("RENDER_digits"))
frame_renumber = get_optional_env("RENDER_renumber", int)
render_out = os.getenv("RENDER_out")
existing_action = os.getenv("RENDER_existing")
frame_start = get_optional_env("RENDER_frame_start", int)
frame_end = get_optional_env("RENDER_frame_end", int)
frame_step = get_optional_env("RENDER_frame_step", int)
render_samples = get_optional_env("RENDER_samples", int)
nr_render_threads = os.getenv("RENDER_threads")
if nr_render_threads == "" :
    nr_render_threads = None
#end if
render_threads_mode = None # default
if nr_render_threads != None :
    if nr_render_threads.lower() == "auto" :
        render_threads_mode = "AUTO"
        nr_render_threads = None
    else :
        try :
            nr_render_threads = int(nr_render_threads)
        except ValueError :
            raise ValueError("invalid number of --threads")
        #end try
        if nr_render_threads < 1 :
            raise ValueError("invalid value for number of --threads")
        #end if
        render_threads_mode = "FIXED"
    #end if
#end if
scene_name = get_optional_env("RENDER_scene")
camera_names = []
i = 0
while True :
    i += 1
    camera_name = get_optional_env("RENDER_camera_{}".format(i))
    if camera_name == None :
        break
    camera_names.append(camera_name)
#end while
arrange = get_optional_env("RENDER_arrange")
arrange_limit = None
if arrange != None :
    arrange = arrange.split(":")
    if len(arrange) > 1 :
        arrange, arrange_limit = arrange
        arrange_limit = int(arrange_limit)
    else :
        arrange = arrange[0]
    #end if
#end if
assert not vse_render or stereo_offset == None and len(camera_names) == 0
layers_str = os.getenv("RENDER_layers", None)
use_camera_layers = os.getenv("RENDER_use_camera_layers", "") != ""
if scene_name != None :
    bpy.context.screen.scene = bpy.data.scenes[scene_name]
#end if
active_scene = bpy.context.scene

if frame_start == None :
    frame_start = remap_frame_nr((active_scene.frame_current, active_scene.frame_start)[animation])
#end if
if animation :
    if frame_end == None :
        frame_end = remap_frame_nr(active_scene.frame_end)
    #end if
    if frame_step == None :
        frame_step = active_scene.frame_step
    #end if
else :
    frame_end = frame_start
    frame_step = 1
#end if
if animation :
    if frame_renumber != None :
        frame_nr_adjust = frame_renumber - frame_start
    else :
        frame_nr_adjust = 0
    #end if
    if frame_end < frame_start :
        raise ValueError("invalid frame number range")
    #end if
    if frame_start + frame_nr_adjust <= 0 :
        raise ValueError("frame numbers go non-positive")
    #end if
    if frame_end + frame_nr_adjust >= 10 ** frame_digits :
        raise ValueError("not enough digits for frame numbers")
    #end if
#end if
sys.stdout.write("frame range = %d to %d by %d\n" % (frame_start, frame_end, frame_step)) # debug

need_worktemp = len(camera_names) > 1 or stereo_offset != None or rotate != 0
if animation and existing_action == "replace-all" :
    # Create a temporary output directory into which to save the new frames.
    # This is not automatically deleted on error, so you at least get the
    # partial results. If the directory already exists, then skip rendering
    # of any frames that are already present. This allows resuming from a crash.
    if render_out.endswith("/") :
        render_out = render_out[:-1]
    #end if
    outtempdir = "{}-tmp".format(render_out)
    try :
        os.mkdir(outtempdir)
    except FileExistsError :
        pass
    #end try
    use_render_out = outtempdir
else :
    if existing_action != "skip" :
        crash_protect = False # not supported for now
    #end if
    outtempdir = None
    use_render_out = render_out
#end if

if crash_protect :
    frames_undone = \
        (
            set(frame_name(f) for f in range(frame_start, frame_end + 1, frame_step))
        -
            set(os.listdir(use_render_out))
        )
    sys.stdout.write("initial frames_undone = %s\n" % repr(frames_undone)) # debug
    crash_count = 0
#end if
while True :
    if crash_protect :
        child_pid = os.fork()
    else :
        child_pid = 0
    #end if
    if child_pid == 0 :
        with (DummyTempDir, tempfile.TemporaryDirectory)[need_worktemp](prefix = "render-") as tempdir :
            temp_image_names = None
            if len(camera_names) > 1 :
                temp_image_names = tuple("camera_{}".format(i + 1) for i in range(len(camera_names)))
            elif stereo_offset != None :
                temp_image_names = ("left", "right")
            elif rotate != 0 :
                temp_image_names = ("unrotated",)
            #end if
            if temp_image_names != None :
                temp_image_names = tuple(os.path.join(tempdir, name) + ".png" for name in temp_image_names)
            #end if

            if layers_str != None :
                set_layers(*parse_layers_spec(layers_str))
            #end if
            if time_remap != None :
                active_scene.render.frame_map_old = time_remap[0]
                active_scene.render.frame_map_new = time_remap[1]
            #end if
            if len(camera_names) == 1 :
                active_scene.camera = bpy.data.objects[camera_names[0]]
            #end if
            if render_samples != None :
                if (
                        hasattr(active_scene, "cycles")
                    and
                        active_scene.render.engine == "CYCLES"
                ) :
                     active_scene.cycles.samples = render_samples
                elif (
                        active_scene.render.engine == "BLENDER_RENDER"
                    and
                        active_scene.world.light_settings.gather_method == "RAYTRACE"
                ) :
                    active_scene.world.light_settings.samples = render_samples
                else :
                    raise ValueError \
                      (
                        "--samples value only valid for Cycles renderer, or for"
                        " BI renderer in Raytrace gather mode"
                      )
                #end if
            #end if
            if render_threads_mode != None :
                active_scene.render.threads_mode = render_threads_mode
            #end if
            if nr_render_threads != None :
                active_scene.render.threads = nr_render_threads
            #end if
            active_camera = active_scene.camera
            if not vse_render :
                orig_camera_matrix = active_camera.matrix_basis.copy()
            #end if

            if render_width != None or render_height != None :
                # maintain aspect ratio if only one is specified
                if render_width == None :
                    render_width = round(render_height * active_scene.render.resolution_x / active_scene.render.resolution_y)
                #end if
                if render_height == None :
                    render_height = round(render_width * active_scene.render.resolution_y / active_scene.render.resolution_x)
                #end if
                active_scene.render.resolution_x = render_width
                active_scene.render.resolution_y = render_height
            #end if
            if render_percentage != None :
                if isinstance(render_percentage, float) :
                    active_scene.render.resolution_x = \
                        round(active_scene.render.resolution_x * render_percentage / 100)
                    active_scene.render.resolution_y = \
                        round(active_scene.render.resolution_y * render_percentage / 100)
                    active_scene.render.resolution_percentage = 100
                else : # isinstance(render_percentage, int)
                    active_scene.render.resolution_percentage = render_percentage
                #end if
            #end if

            active_scene.render.image_settings.file_format = "PNG"
            compose_offset = None
            if preexec != None :
                exec(preexec)
            #end if
            start_time = time.time()
            frames_done = 0
            for frame_nr in range(frame_start, frame_end + 1, frame_step) :
                if animation :
                    out_image_name = os.path.join(use_render_out, frame_name(frame_nr))
                else :
                    out_image_name = render_out
                #end if
                if existing_action == "overwrite" or not os.path.exists(out_image_name) :
                    active_scene.frame_set(frame_nr)
                    if use_camera_layers and len(camera_names) <= 1 :
                        set_layers_from_object(active_scene.camera)
                    #end if
                    if len(camera_names) > 1 :
                        for i in range(len(camera_names)) :
                            active_scene.camera = bpy.data.objects[camera_names[i]]
                            if use_camera_layers :
                                set_layers_from_object(active_scene.camera)
                            #end if
                            active_scene.render.filepath = temp_image_names[i]
                            bpy.ops.render.render(write_still = True)
                        #end for
                        for i in range(len(temp_image_names)) :
                            image = get_image_from_png(temp_image_names[i])
                            if i == 0 :
                                image_dimensions = image.dimensions
                                compose_step = Vector \
                                  (
                                    (0, 1)[arrange == "across"],
                                    (0, 1)[arrange == "down"]
                                  )
                                if arrange_limit != None and arrange_limit < len(temp_image_names) :
                                    compose_step_2 = Vector(compose_step.y, compose_step.x)
                                    composite_steps = \
                                        (
                                            compose_step * arrange_limit
                                        +
                                                compose_step_2
                                            *
                                                ((len(temp_image_names) + arrange_limit - 1) // arrange_limit)
                                        )
                                else :
                                    compose_step_2 = None
                                    composite_steps = Vector(1, 1) + compose_step * (len(temp_image_names) - 1)
                                #end if
                                concat = qah.ImageSurface.create \
                                  (
                                    format = CAIRO.FORMAT_RGB24,
                                    dimensions = image_dimensions * composite_steps
                                  )
                                compose = \
                                    (qah.Context.create(concat)
                                        .set_operator(CAIRO.OPERATOR_SOURCE)
                                        .set_source_colour(Colour.grey(0, 0))
                                        .paint()
                                    )
                            #end if
                            if compose_step_2 != None :
                                compose_pos = \
                                    (
                                        image_dimensions
                                    *
                                        (
                                            compose_step * (i % arrange_limit)
                                        +
                                            compose_step_2 * (i // arrange_limit)
                                        )
                                    )
                            else :
                                compose_pos = image_dimensions * compose_step * i
                            #end if
                            compose.set_source_surface(image, compose_pos)
                            compose.rectangle(Rect.from_dimensions(image_dimensions) + compose_pos)
                            compose.fill()
                        #end for
                        concat.flush()
                        concat.write_to_png(out_image_name)
                    elif stereo_offset != None :
                        for sign in (-1, +1) : # left eye, then right eye
                            active_scene.render.filepath = temp_image_names[sign > 0]
                            active_camera.matrix_basis = \
                                (
                                    orig_camera_matrix
                                *
                                    mathutils.Matrix.Translation(mathutils.Vector((sign * stereo_offset, 0, 0)))
                                )
                            bpy.ops.render.render(write_still = True)
                        #end for
                        left_eye = get_image_from_png(temp_image_names[0])
                        right_eye = get_image_from_png(temp_image_names[1])
                        if crossed :
                            left_eye, right_eye = right_eye, left_eye
                        #end if
                        if compose_offset == None :
                            compose_offset = left_eye.width
                            image_height = left_eye.height
                        #end if
                        stereo = qah.ImageSurface.create \
                          (
                            format = CAIRO.FORMAT_RGB24,
                            dimensions = (compose_offset * 2, image_height)
                          )
                        (qah.Context.create(stereo)
                            .set_operator(CAIRO.OPERATOR_SOURCE)
                            .set_source_colour(Colour.grey(0, 0))
                            .paint()
                            .set_source_surface(right_eye, (0, 0))
                            .rectangle(Rect(0, 0, compose_offset, image_height))
                            .fill()
                            .set_source_surface(left_eye, (compose_offset, 0))
                            .rectangle(Rect(compose_offset, 0, compose_offset, image_height))
                            .fill()
                        )
                        stereo.flush()
                        stereo.write_to_png(out_image_name)
                    elif rotate != 0 :
                        active_scene.render.filepath = temp_image_names[0]
                        bpy.ops.render.render(write_still = True)
                        get_image_from_png(temp_image_names[0]).write_to_png(out_image_name)
                    else :
                        active_scene.render.filepath = out_image_name
                        bpy.ops.render.render(write_still = True)
                    #end if
                    frames_done += 1
                elif existing_action in ("skip", "replace-all") :
                    sys.stdout.write("Skipped {}\n".format(out_image_name))
                else :
                    raise RuntimeError("Output image “{}” already exists".format(out_image_name))
                #end if
            #end for
            if outtempdir != None :
                if os.path.islink(render_out) :
                    os.remove(render_out)
                elif os.path.isdir(render_out) :
                    shutil.rmtree(render_out)
                #end if
                sys.stdout.write("Rename dir {} => {}\n".format(outtempdir, render_out))
                os.rename(outtempdir, render_out)
            #end if
            now = time.time()
            sys.stdout.write \
              (
                    "Rendered {} {} in {}\n".format
                      (
                        frames_done,
                        ("frame", "frames")[frames_done != 1],
                        format_elapsed(now - start_time)
                      )
              )
        #end with
        if crash_protect :
            # Blender seems to get confused over threading in the child process,
            # and hangs instead of quitting.
            # sys.exit(0) -- does exit, but parent gets signal.SIGSEGV status
            os._exit(0) # bypass all userland cleanup processing
        else :
            break
        #end if
    else :
        status = os.waitpid(child_pid, 0)[1]
        sys.stdout.write("Child termination status = %d\n" % status)
        if existing_action == "replace-all" and not os.path.isdir(outtempdir) :
            new_frames_undone = set()
        else :
            new_frames_undone = frames_undone - set(os.listdir(use_render_out))
        #end if
        if len(new_frames_undone) == 0 :
            # looks like render has completed successfully
            if crash_count != 0 :
                sys.stdout.write("Completed after %d crashes.\n" % crash_count)
            #end if
            break
        #end if
        # not finished nicely, assume crash
        crash_count += 1
        # only continue as long as actual progress is being made
        if len(new_frames_undone) == len(frames_undone) :
            sys.stdout.write("Giving up after %d crashes.\n" % crash_count)
            break
        #end if
        frames_undone = new_frames_undone
        sys.stdout.write("Crash restart %d\n" % crash_count)
        sys.stdout.write("frames_undone = %s\n" % repr(frames_undone)) # debug
    #end if
#end while

EOD
)
