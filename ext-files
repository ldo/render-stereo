#!/bin/bash
#+
# This script displays information about a specified .blend file,
# namely external image, library, font and sound files that it
# depends on. Invoke it as follows:
#
#     ext-files [options...] blendfile
#
# where the valid options are
#
#    --blender=blender
#          specifies the path to the Blender executable. Defaults to
#          searching for the name “blender” in your PATH.
#    --full
#          spacies that details about the dependencies are to be
#          printed in JSON format. Otherwise only the file paths are
#          printed, one to a line.
#    --presence
#          also includes the status of each external file, whether it
#          could be found (and read) or not.
#    --test-requires=depfile
#          don’t produce any output, but return a success/failure exit
#          status if blendfile does/does not have depfile as a dependency
#          respectively. Incompatible with the --full or --presence options.
#
# Copyright 2015-2016 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY-SA <http://creativecommons.org/licenses/by-sa/4.0/>.
#-

blender=blender
full_json=
presence=
test_requires=
for ((;;)); do
    if [ "${1:0:2}" != "--" ]; then
        break
    fi
    if [ "$1" == "--" ]; then
        shift
        break
    fi
    opt="${1:2:${#1}}"
    shift
    val="${opt#*=}"
    opt="${opt%%=*}"
    if [ "$opt" = "blender" ]; then
        blender="$val"
    elif [ "$opt" = "full" ]; then
        full_json=1
    elif [ "$opt" = "presence" ]; then
        presence=1
    elif [ "$opt" = "test-requires" ]; then
        test_requires="$val"
    else
        echo "$0: bad option $opt" 1>&2
        exit 3
    fi
done
if [ -n "$test_requires" ]; then
    if [ "$full_json" -o "$presence" ]; then
        echo "$0: --test_requires incompatible with --full or --presence" 1>&2
        exit 3
    fi
fi
if [ -z "$(type -p "$blender")" ]; then
    echo "$0: no such executable “$blender”" 1>&2
    exit 3
fi
if [ $# != 1 ]; then
    echo $'Usage:\n\t'"$0" $'<blendfile>\n' 1>&2
    exit 3
fi
export RENDER_blendfile="$1"
export RENDER_full_json="$full_json"
export RENDER_presence="$presence"
export RENDER_test_requires="$test_requires"

exec "$blender" 5>&1 1>/dev/null -b -P <(cat <<'EOD'
import sys
import os
import json
import bpy

def expand_path(path, allow_curdir_relative) :
    # normalizes path to be a full pathname. Requires parent_dir to be
    # defined as the parent directory of the .blend file for
    # interpreting relative paths.
    if path.startswith("//") :
        # Blender convention for path relative to .blend file
        path = os.path.join(parent_dir, path[2:])
    elif not path.startswith("/") :
        if allow_curdir_relative :
            path = os.path.abspath(path)
        else :
            # not expecting a path relative to anything else!
            path = None
        #end if
    #end if
    return \
        path
#end expand_path

def path_ok(path) :
    # checks that the file at path exists and is accessible.
    path = expand_path(path, False)
    return \
        (
            path != None
        and
            os.access(path, os.R_OK)
              # technically I would rather use Linux eaccess(2),
              # but Python doesn’t offer that...
        )
#end path_ok

out = os.fdopen(5, "w")
  # use a different fd from stdout, only way it seems to avoid
  # output being polluted by Blender’s messages

blendfile = os.getenv("RENDER_blendfile")
bpy.ops.wm.open_mainfile(filepath = blendfile)
full_json = os.getenv("RENDER_full_json", "") != ""
presence = os.getenv("RENDER_presence", "") != ""
test_requires = os.getenv("RENDER_test_requires")
if test_requires == "" :
    test_requires = None
#end if

if full_json :
    out.write("{")
    first_cat = True
#end if
if presence or test_requires != None :
    parent_dir = os.path.split(os.path.abspath(bpy.data.filepath))[0]
#end if
found = False
if test_requires != None :
    test_requires = expand_path(test_requires, True)
#end if
exit_status = 0
for \
    category, match, mismatch, extra \
in \
    (
        ("fonts", {}, (("filepath" , "<builtin>"),), ()),
        ("images", {"type" : "IMAGE"}, (), ("filepath_raw",)),
        ("libraries", {}, (), ()),
        ("sounds", {}, (), ()),
    ) \
:
    if full_json :
        cat_started = False
    #end if
    for item in getattr(bpy.data, category) :
        if (
                item.packed_file == None
            and
                not any(getattr(item, k) == v for k, v in mismatch)
            and
                all(getattr(item, k) == match[k] for k in match)
        ) :
            if full_json :
                if not cat_started :
                    if full_json :
                        if first_cat :
                            first_cat = False
                        else :
                            out.write(",")
                        #end if
                        out.write("\n    %s:\n        [" % json.dumps(category))
                        first_item = True
                    #end if
                    cat_started = True
                #end if
                if first_item :
                    first_item = False
                else :
                    out.write(",")
                #end if
                out.write("\n            {")
                first_attr = True
                for attr in ("name", "filepath") + extra :
                    if first_attr :
                        first_attr = False
                    else :
                        out.write(",")
                    #end if
                    value = getattr(item, attr)
                    out.write \
                      (
                            "\n                %s: %s"
                        %
                            (json.dumps(attr), json.dumps(value))
                      )
                    if presence and attr == "filepath" :
                        out.write \
                          (
                                ",\n                \"present\": %s"
                            %
                                ("false", "true")[path_ok(value)]
                          )
                    #end if
                #end for
                out.write("\n            }")
            elif test_requires == None :
                if presence :
                    out.write("%s: " % ("missing", "present")[path_ok(item.filepath)])
                #end if
                out.write(item.filepath + "\n")
            else :
                if expand_path(item.filepath, False) == test_requires :
                    found = True
                    break
                #end if
            #end if
        #end if
    #end for
    if found :
        break
    #end if
    if full_json and cat_started :
        out.write("\n        ]")
    #end if
#end for
if full_json :
    out.write("\n}\n")
#end if
if test_requires != None :
    exit_status = 1 - int(found)
else :
    out.flush()
#end if
sys.exit(exit_status)
EOD
)
